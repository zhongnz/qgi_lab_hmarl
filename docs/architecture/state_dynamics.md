# State Dynamics Reference

> Formal equations governing every state variable in the simulation.
> All code references point to `hmarl_mvp/dynamics.py` and `hmarl_mvp/env.py`.

---

## Notation

| Symbol | Meaning | Config key |
|--------|---------|------------|
| $dt$   | Simulation time step (hours) | `dt_hours = 1.0` |
| $p$    | Weather penalty factor | `weather_penalty_factor = 0.15` |
| $s_{ij}$ | Sea state on route $i \to j$ | generated by weather model |
| $c$    | Cubic fuel rate coefficient | `fuel_rate_coeff = 0.002` |
| $e$    | Emission factor (CO₂ / fuel ton) | `emission_factor = 3.114` |
| $d_{ij}$ | Great-circle distance (nm) from port $i$ to port $j$ | `distance_nm[i,j]` |

---

## Vessel state variables

Each vessel $k$ has state $(x_k, v_k, F_k, E_k, \ell_k, h_k)$:

| Variable | Field | Meaning |
|----------|-------|---------|
| $x_k$    | `position_nm` | Distance travelled on current leg (nm) |
| $v_k$    | `speed` | Current commanded speed (kn) |
| $F_k$    | `fuel` | Remaining fuel (tons) |
| $E_k$    | `emissions` | Cumulative CO₂ emitted (tons) |
| $\ell_k$ | `location` | Current port index (when docked) |
| $h_k$    | `delay_hours` | Accumulated delay (hours) |

### Weather functions

$$\mu(s) = 1 + p \cdot s \qquad \text{(fuel multiplier)}$$

$$f_w(s) = \frac{1}{\mu(s)} = \frac{1}{1 + p \cdot s} \qquad \text{(effective speed fraction)}$$

Code: `dynamics.weather_fuel_multiplier`, `dynamics.weather_speed_factor`

### Position update (at-sea vessels)

$$x_k^{(t+1)} = x_k^{(t)} + v_k \cdot dt \cdot f_w(s_{ij})$$

where $i = \texttt{vessel.location}$, $j = \texttt{vessel.destination}$.
When $s = 0$ (no weather or weather disabled) this reduces to $x_k^{(t+1)} = x_k^{(t)} + v_k \cdot dt$.

Code: `dynamics.step_vessels` — `vessel.position_nm += effective_advance`

### Arrival condition

$$x_k \geq d_{ij} \implies \text{vessel } k \text{ arrives at port } j$$

On arrival: `at_sea = False`, `position_nm = 0`, `location = j`, and `ports[j].queue += 1`.

### Fuel consumption per tick

$$\Delta F_k = c \cdot v_k^3 \cdot dt \cdot \mu(s_{ij})$$

$$F_k^{(t+1)} = \max\!\left(F_k^{(t)} - \Delta F_k,\; 0\right)$$

The cubic term ($v^3$) is the standard Admiralty formula: fuel scales with the
cube of speed, giving a strong incentive for learned policies to slow down in
non-urgent legs. Code: `dynamics.compute_fuel_and_emissions`

### Emissions per tick

$$\Delta E_k = \Delta F_k \cdot e$$

$$E_k^{(t+1)} = E_k^{(t)} + \Delta E_k$$

### Delay accumulation

While a vessel is docked and awaiting a slot response (or the slot is rejected):

$$h_k^{(t+1)} = h_k^{(t)} + dt$$

Code: `env.MaritimeEnv.step` — `vessel.delay_hours += 1.0`

### Departure window

When the fleet coordinator issues a directive with `departure_window_hours = W`:

$$t_{\text{depart}} = t_{\text{accept}} + \left\lfloor W / dt \right\rfloor \text{ steps}$$

Until $t \geq t_{\text{depart}}$ the vessel is in `pending_departure = True` and
`at_sea = False`. Code: `dynamics.dispatch_vessel`, `dynamics.step_vessels`

---

## Port state variables

Each port $j$ has state $(Q_j, D_j, O_j, \tau_j, W_j, N_j)$:

| Variable | Field | Meaning |
|----------|-------|---------|
| $Q_j$    | `queue` | Vessels waiting for a berth |
| $D_j$    | `docks` | Total dock capacity (`docks_per_port`, default 3) |
| $O_j$    | `occupied` | Docks currently in service: $O_j = |\tau_j|$ |
| $\tau_j$ | `service_times` | List of remaining service times per occupied berth |
| $W_j$    | `cumulative_wait_hours` | Total vessel-hours of queue waiting |
| $N_j$    | `vessels_served` | Count of vessels that have completed service |

### Service time countdown

Each occupied berth decrements by $dt$ per tick:

$$\tau_{j,b}^{(t+1)} = \max\!\left(\tau_{j,b}^{(t)} - dt,\; 0\right)$$

Berths whose countdown reaches zero are freed: $O_j$ decreases accordingly.

### Queue evolution

At each port tick, let $\text{served}$ denote the number admitted this step
(bounded by queue size, service rate action, and available berths):

$$Q_j^{(t+1)} = \max\!\left(Q_j^{(t)} - \text{served}_t + \text{arrivals}_t,\; 0\right)$$

where $\text{arrivals}_t$ is the number of vessels that completed their leg to
port $j$ during this tick.

### Cumulative wait

$$W_j^{(t+1)} = W_j^{(t)} + Q_j^{(t)} \cdot dt$$

This is time-weighted queue length (vessel-hours).

Code: `dynamics.step_ports`

---

## Weather dynamics (AR(1))

The weather matrix $\mathbf{S}^{(t)} \in \mathbb{R}^{P \times P}$ is a symmetric
sea-state matrix where $S^{(t)}_{ij}$ is the sea state on route $i \to j$.

$$\mathbf{S}^{(t+1)} = \alpha \cdot \mathbf{S}^{(t)} + (1 - \alpha) \cdot \boldsymbol{\varepsilon}^{(t)}$$

where $\boldsymbol{\varepsilon}^{(t)} \sim U\!\left(0, s_{\max}\right)$ (symmetric,
zero diagonal) and $\alpha = \texttt{weather\_autocorrelation}$ (default 0.0
→ i.i.d. each step; typical use: 0.7).

All entries are clipped to $[0, s_{\max}]$ and the matrix is re-symmetrised.
When weather is disabled (`weather_enabled = False`) the multiplier $\mu(s) = 1$
and no weather penalty is applied.

Code: `dynamics.update_weather_ar1`, `dynamics.generate_weather`

---

## Fleet Coordinator state

The coordinator tracks:

| Variable | Field | Meaning |
|----------|-------|---------|
| $B_e$    | `emission_budget` | Fleet-wide CO₂ budget for the current horizon |
| $E_{\text{total}}$ | `cumulative_emissions` | $\sum_k E_k$ at last coordinator step |
| $\Delta_{\text{coord}}$ | `coord_decision_interval_steps` | Steps between coordinator actions (default 12) |

The coordinator issues directives $(\text{dest port}_k, W_k, B_e)$ for each
assigned vessel $k$ every $\Delta_{\text{coord}}$ steps. Directives are
delivered after `message_latency_steps` steps.

Setting `message_latency_steps = 1` (the minimum) effectively makes delivery
synchronous within one simulation step. This value can be set to 0 only if the
asynchronous bus is bypassed entirely (not the current default).

---

## Decision cadence

Three independent cadences govern when each agent type acts:

| Agent type | Default interval | Config key |
|------------|-----------------|------------|
| Coordinator | every 12 steps | `coord_decision_interval_steps` |
| Vessel | every 1 step | `vessel_decision_interval_steps` |
| Port | every 2 steps | `port_decision_interval_steps` |

When an agent is not due (`due[type] == False`), its last action is re-used.
The message bus latency adds `message_latency_steps` ticks between action and
effect. To remove asynchrony entirely, set `message_latency_steps = 1` and
all `*_decision_interval_steps = 1`.

Code: `config.DecisionCadence.due`
